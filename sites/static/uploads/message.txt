#include "HttpResponseHandler.hpp"
#include <iostream>  //debug

namespace fs = std::filesystem; // Alias for filesystem


static bool extractMultipartFile(const HttpRequest& req, std::string& outFileData)
{
	// Get Content-Type
	if (!req.getHeaders().count("content-type"))
	{
		std::cout << "1\n";
		return false;
	}

	std::string ct = req.getHeaders().at("content-type");
	size_t bpos = ct.find("boundary=");
	if (bpos == std::string::npos)
	{
		std::cout << "2\n";
		return false;
	}
	std::string boundary = ct.substr(bpos + 9);
	std::string marker = "--" + boundary;

	const std::string& body = req.getBody();
	std::cout << "debug" << body << std::endl;

	// Find first boundary
	size_t partStart = body.find(marker);
	if (partStart == std::string::npos)
	{
		std::cout << "3\n";
		return false;
	}
	partStart += marker.size();
	if (body.compare(partStart, 2, "\r\n") == 0)
		partStart += 2;

	// Skip multipart headers
	size_t dataStart = body.find("\r\n\r\n", partStart);
	if (dataStart == std::string::npos)
	{
		std::cout << "4\n";
		return false;
	}
	dataStart += 4; // skip CRLF CRLF

	// Find end of file data
	size_t markerPos = body.find( marker, dataStart);
	if (markerPos == std::string::npos)
	{
		std::cout << "5\n";
		return false;
	}
	size_t dataEnd = markerPos;
	if (dataEnd >= 2 && body.compare(dataEnd - 2, 2, "\r\n") == 0)
		dataEnd -= 2;
	// Extract file bytes
	outFileData.assign(body.data() + dataStart, dataEnd - dataStart);
	return true;
}

// --------------------
// Internal Utility Methods
// --------------------
/**
 * @brief parse the output from CGI execution into an HttpResponse object
 *
 * @param out raw output string from CGI execution of lin
 * @param req the HttpRequest object (used to determine keep-alive)
 * @return HttpResponse object representing the CGI response
 *
 * @note used when CGI script is executed and its output needs to be converted into an HTTP response
 * @note CGI :common gateway Interface
 * @note CGI path is the filesystem path to the cgi executable program:
 *
 * @example
 * Status: 200 OK\r\n
 * Content-Type: text/html\r\n
 * \r\n
 * <html>...</html>
 */
HttpResponse HttpResponseHandler::parseCGIOutput(const std::string& out, const HttpRequest& req, const config::ServerConfig* vh){
   //it is after last header valuse and then the empty line
   //Note from lucio, should check both "\r\n\r\n"(for python) and "\n\n" (for php and bash)
   size_t pos = out.find("\r\n\r\n");
   size_t sepLen = 4; // NOTE 15.12, when \r\n\r\n, it the length should be 4
   if (pos == std::string::npos){
      pos = out.find("\n\n");
      sepLen = 2; // NOTE 15.12, when \n\n, it the length should be 2
      if (pos == std::string::npos){
         return makeErrorResponse(500, vh);
      }
   }

   std::string headersString = out.substr(0, pos);
   std::string bodyString = out.substr(pos + sepLen); // NOTE 15.12

   std::string statusCode = "200";
   std::string statusMsg = "OK";

   std::map<std::string, std::string>  headersMap;

   std::istringstream ss(headersString);
   std::string       line;

   while (std::getline(ss, line))
   {
      if (!line.empty() && line.back() == '\r') //getline removes \n but not \related
         line.pop_back();
      size_t dd = line.find(":");
      std::string key = line.substr(0, dd);
      std::string val = line.substr(dd + 1);
      key = httpUtils::trim_space(key);
      val = httpUtils::trim_space(val);

      // check if it is special status code in headerlines
      // eg: Status: 404 Not Found
      if (key == "Status") {
         size_t space = val.find(" ");
         statusCode = val.substr(0, space);
         statusMsg  = val.substr(space + 1);
      }
      else
         headersMap[key] = val;
   }
   // manually setup this one
   headersMap["Content-Length"] = std::to_string(bodyString.size());

   // Check if CGI already set Content-Type, otherwise use default
   if (headersMap.find("Content-Type") == headersMap.end()) {
      headersMap["Content-Type"] = "text/html; charset=UTF-8";
   }

   return HttpResponse("HTTP/1.1", std::stoi(statusCode), statusMsg, bodyString, headersMap, httpUtils::shouldKeepAlive(req), true);
}

/**
 * @brief   Generates an HTML directory listing for autoindex
 *
 * @param   dirPath the directory path
 * @param   req the HttpRequest object (used for path in links)
 * @return  HttpResponse object containing the autoindex HTML page
 *
 * @note    used to provide directory listings when autoindex is enabled
 */
HttpResponse HttpResponseHandler::generateAutoIndex(const std::string& dirPath, HttpRequest& req)
{
    namespace fs = std::filesystem;
    std::string body = "<html><head><title>Index of " + req.getPath() + "</title></head><body>";
    body += "<h1>Index of " + req.getPath() + "</h1><ul>";

    for (const auto& entry : fs::directory_iterator(dirPath))
    {
        std::string name = entry.path().filename().string();
        body += "<li><a href=\"" + req.getPath();
        if (req.getPath().back() != '/')
            body += "/";
        body += name + "\">" + name + "</a></li>";
    }

    body += "</ul></body></html>";

    std::map<std::string, std::string> headers;
    headers["Content-Type"] = "text/html";
    headers["Content-Length"] = std::to_string(body.size());
    headers["Server"] = "MiniWebserv/1.0";
    headers["Date"] = httpUtils::formatTime(time(NULL));

    return HttpResponse("HTTP/1.1", 200, "OK", body, headers, httpUtils::shouldKeepAlive(req), true);
}

// --------------------
//  InternalHandlers for different HTTP methods
// --------------------
HttpResponse HttpResponseHandler::handleGET(HttpRequest& req, const config::ServerConfig* vh)
{
   // get the request URI: uniform Resource Identifier, _path in the request
   std::string fullUri = req.getPath();  // Full URI including query string

   // Split URI from query parameters
   std::string uri = fullUri;
   size_t queryPos = fullUri.find('?');
   if (queryPos != std::string::npos) {
      uri = fullUri.substr(0, queryPos);
   }
   if (httpUtils::isCgiRequest(req, *vh)){
      const config::LocationConfig* lc = httpUtils::findLocationConfig(vh, uri, "GET");
      if (!lc){
         return makeErrorResponse(403, vh);
      }
      CGI cgi(req, *lc);
      if (!cgi.isAllowedCgi()){
        return makeErrorResponse(403, vh);
      }
      std::string cgi_output = cgi.execute();
      if (cgi_output.empty() || cgi_output == "CGI_EXECUTE_FAILED")
         return makeErrorResponse(500, vh);
      return parseCGIOutput(cgi_output, req, vh);
   }

    // First find LocationConfig check if it is cgi
   const config::LocationConfig* lc = httpUtils::findLocationConfig(vh, uri, "GET");
   if (!lc)
      return makeErrorResponse(404, vh);

   // If location path ends with / but uri doesn't, normalize uri for path mapping
   if (lc->path.length() > 1 && lc->path.back() == '/' && !uri.empty() && uri.back() != '/') {
      // Check if uri matches location without trailing slash
      std::string locWithoutSlash = lc->path.substr(0, lc->path.length() - 1);
      if (uri == locWithoutSlash) {
         uri += "/";  // Add trailing slash for consistent path mapping
      }
   }
   // Check for configured redirect
   if (!lc->redirect.empty()) {
      return makeRedirect301(lc->redirect, vh);
   }
   // map URI to path. for example: /hello â†’ filesystem path (e.g., /var/www/html/hello).
   std::string fullpath = httpUtils::mapUriToPath(lc, uri);

   // Checked if the file exists, is readable, and is a regular file: exits(), is_regular_file, access(R_OK)
   struct stat st;
   if (stat(fullpath.c_str(), &st) == 0)
   {
      if (S_ISDIR(st.st_mode))
      {
         // URI does NOT end with '/'
         if (uri.empty() || uri.back() != '/')
            return makeRedirect301(uri + "/", vh);

         // Now check method after redirect handled
         if (!httpUtils::isMethodAllowed(lc, "GET"))
            return makeErrorResponse(405, vh);

         //try index files
         std::string index_file = httpUtils::getIndexFile(fullpath, lc);
    