Yuxin\s notes

====================================================== Git Repo ======================================================
-Lucio started the repo and invited me, we will have 3 different branch there, I ren amed it team 
-I have a remote link repo origin 
- then at team repo, I git remote add origin https://github.com/Yuxin29/Webserver.git 
- I will work in shared team repo, and git push origin my_branch / main normally there 
- to update it to my personal redo, I do git push -u origin my_branch / main there 
- when project is over, I WILL git remote remove team

====================================================== Teamwork flow ======================================================
                 ┌────────────────────┐
                 │     Client         │
                 └─────────┬──────────┘
                           │  HTTP request
                           ▼
             ┌───────────────────────────────────┐
             │       A: Network & I/O Manager    │
             │---------------------------------- │
             │ - Accepts connections             │
             │ - poll/select/epoll monitors FDs  │
             │ - Non-blocking read/write         │
             └───────────┬───────────────────────┘
                         │ raw bytes
                         ▼
            ┌─────────────────────────────────────┐
            │   B: HTTP Request/Response Handler  │
            │-------------------------------------│
            │ - Parse HTTP request                │
            │ - Apply HTTP rules                  │
            │ - Determines action (static/CGI/etc)│
            └──────────┬───────────────┬──────────┘
                       │               │
           asks for config rules   needs CGI process
                       │               │
                       ▼               ▼
     ┌──────────────────────────────────────────────┐
     │        C: Configuration & CGI Manager        │
     │----------------------------------------------│
     │ - server.conf parser                         │
     │ - location/root/index/error_pages            │
     │ - CGI execution (execve)                     │
     │ - file path resolution                       │
     └──────────────────┬───────────────────────────┘
                        │ response data (file/CGI output)
                        ▼
            ┌─────────────────────────────────────┐
            │    B builds full HTTP response      │
            └──────────────────┬──────────────────┘
                               │ final bytes
                               ▼
             ┌────────────────────────────────────┐
             │    A: Sends response to client     │
             └────────────────────────────────────┘

====================================================== Lin sent from wahtsapp ======================================================
A|Network & I/O Manager |- Set up listening sockets		
-Handle poll() / select() / epoll()
-Manage client connections and file descriptors | - Implement non-blocking I/O logic
-Manage read/write events
-Prevent blocking to ensure responsiveness | - Optimize performance under heavy load
-Handle signals and interruptions
Conduct stress tests (e.g., with ab, wrk) |

B | HTTP Request/Response Handler | - Implement HTTP request parser (start-line, headers, body)
-Build HTTP response generator (status line, headers, body)
-Handle basic GET requests | - Add support for POST and DELETE
-Ensure HTTP/1.1 compliance
-Implement proper status codes and headers | - Fine-tune keep-alive behavior
-Match browser and NGINX behavior
-(Optional??) Handle chunked transfer encoding |

C | Configuration & CGI Manager | - Design and implement server.conf parser
-Support directives: server, location, listen, root, index, etc. | - Implement CGI execution (e.g., via execve)
-Add file upload support
-Route requests and handle custom error pages | - Add bonus features: autoindex, redirects
-Prepare demo config files for defense
-Polish docs, error handling, testing scripts |

====================================================== If I want to do my request in 3 weeks ======================================================
第 1 周：HTTP Parser + Request Handling
目标：能解析完整的 HTTP 请求（start-line、headers、body）
✅  ❌ ⏳ ⚠️
------------------------
Day 1 — 架构搭建 + HTTP 基础复习                                                ✅
学习：HTTP/1.1 结构, Request-Line, Headers, CRLF, Body（Content-Length）        ✅
实现：HttpRequest, HttpParser 类骨架                                            ✅

Day 2 — parseRequestLine()
学习：方法 GET/POST/DELETE, URL 格式, HTTP version 校验
实现：parseRequestLine()
测试：printf "GET / HTTP/1.1\r\n\r\n" | nc localhost 8080
Person A 会把收到的数据传给你。

Day 3 — parseHeaders()
学习：key:value, 大小写不敏感, header 合并规则, Host 必须存在（HTTP/1.1 规范）
实现：parseHeaders()
测试：重复 header, 缺少 CRLF
Day 4 — parseBody()（Content-Length）
学习：Content-Length, body 大小限制（防止 413）
实现：parseBody()
测试：curl -d "hello" localhost:8080
Day 5 — 状态机（非阻塞需要）
学习状态机： START_LINE, HEADERS, BODY, DONE
实现： HttpParser::consume(buffer), 能够分段解析（防止 slowloris）
测试：切分的 TCP 包，逐字节输入, 模拟慢速攻击

⭐ 第 2 周：HTTP Response + 各种方法
目标：能正确生成 HTTP/1.1 响应

Day 6 — Response Builder
学习：status line, headers, Content-Length, Connection
实现：HttpResponse::buildResponse()
测试：与 NGINX 对比：curl -v localhost:8080

Day 7 — GET（静态文件）
学习：MIME types, 文件权限, index 文件（可选）
实现：GET handler
测试：curl -v localhost:8080/test.txt

Day 8 — POST
学习：保存 body, safe path, parent directory traversal attacks（避免 ../）
实现：POST handler → 写入文件
测试：curl -X POST -d "x=y" localhost:8080

Day 9 — DELETE
学习：权限检查, 文件不存在返回 404, 如果是目录返回 403（和 NGINX 一样）
实现：DELETE handler
测试：curl -X DELETE localhost:8080/file.txt

Day 10 — 错误处理
学习：
400（Bad Request）
404（Not Found）
413（Payload Too Large）
414（URI Too Long）
500（Internal Server Error）
实现：
buildErrorResponse()

测试：
所有非法输入、超长 URL、大 body。

⭐ 第 3 周：HTTP 行为、浏览器兼容、压力测试（你的部分）
Day 11 — Keep-Alive 行为

学习：Connection: keep-alive,  Connection: close,  HTTP/1.1 默认 keep-alivem HTTP/1.0 默认 close
实现：shouldCloseConnection(), 根据请求头决定连接是否关闭
测试：curl -v localhost:8080, Chrome 测试 Keep-Alive 是否生效。

Day 12 — NGINX 行为对齐
学习：多余空格如何处理, 重复 headers
Host 缺失 → 400
Accept: / 兼容性
实现：parser 容错更新
测试：和 nginx 对比输出：curl -v --raw localhost:8080

Day 13 — Chunked Encoding（可选）
可选内容。
实现：解析 chunked 或 输出 chunked 响应
测试：curl -H "Transfer-Encoding: chunked" -d "test" localhost:8080

Day 14 — 压力测试（你只检查响应逻辑是否正确）
Person A 会跑：
ab -n 5000 -c 100 http://localhost:8080/
wrk -t4 -c200 -d10s http://localhost:8080/
你负责：
不要内存泄漏（检查 parser）
不要重复 free
不要 keep-alive 死循环
Day 15 — 最终清理

代码规范化, 注释,  删除 printf, RFC 遵循检查, 浏览器实机测试

====================================================== HTTP form ======================================================
type of http request:
GET     POST    PUT         PATCH           DELETE  HEAD                            OPTIONS         CONNECT         TRACE
read    create  replace     partial update  delete  like get, but not return body   check methods   build router    for testing
requred by suj: GET, POST, and DELETE

----> a normal http request form
<start-line>\r\n
<header1: value>\r\n
<header2: value>\r\n
...\r\n
\r\n
<body>
------
1. <start-line>\r\n
Method sp _path sp version crlf(Carriage Return and Line Feed)
Get /index.html HTTP/1.1\r\n
------
2. <header1: value>\r\n
Host: example.com\r\n                ← Headers
User-Agent: curl/7.64.1\r\n
Content-Length: 5\r\n
------
3. empty line
\r\n 
------
4. Body, only for POST, PUT
hello 

----> a normal http response form
<status-line>\r\n
<header1: value>\r\n
...\r\n
\r\n
<body>
------
1.<status-line>\r\n
VERSION SP STATUS_CODE SP REASON_PHRASE CRLF
HTTP/1.1 200 OK\r\needs
2.<headern: value>\r\n
Content-Type: text/html\r\n
Content-Length: 13\r\n
3. empty line
\r\need
4. body:
a string: like "hello world"

====================================================== MAP container that stores key–value pairs ======================================================
#include <map>
--> std::map
- ordered assoiative container
- automateically keeps the keys sorted
- each key must be unique
- Lookup, insertion and deletion are all O(log n)
For example
std::map<std::string, std::string> headers; 
headers["Host"] = "localhost:8080";
headers["User-Agent"] = "curl/7.68.0";
headers["Accept"] = "*/*";
headers["Content-Length"] = "12";

====================================================== State Machine ======================================================
State Machine / Finite State Machine(FSM). it has 3 elements.
1. State,
2. Event / Input   
3. Transition
check state -> get input -> do a thin -> change to next state
---> why do we use state machine in http request parsing
- raw Line comes with a certain order 
- it can avoid lots of if / else if, the step is tracable
- the might be interruption / waiting time between input

====================================================== std::istringstream ======================================================
std::isstringstream is a class that string flows as a stream (eg. reading from a file or socket)
(maybe a bit like a automatic getnext line)
-->>Example use
std::istringstream ss("hello world 42");
std::string a, b;
int num;
ss >> a >> b >> num;
// a = "hello"
// b = "world"
// num = 42

