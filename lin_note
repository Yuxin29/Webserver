â­ ğŸ”¥ 3-Day CGI Plan (Single Interpreter, e.g. Python)
ğŸŸ¦ DAY 1 â€” Build the CGI Execution Engine (core fork/exec part)

Goal: Make execve() run your CGI script and capture output.
NO POST yet, NO headers parsing yet. Only GET.

Morning (2 hours) â€” Set up detection
âœ” Implement these in your runtime router:

loc.cgi_pass not empty

request path ends with loc.cgi_ext (e.g. .py)

If both true â†’ this request is â€œCGI requestâ€.

Do not run script yet, just detect it.

Test with prints:

Request /test.py â†’ PRINT â€œRun CGIâ€

Afternoon (3 hours) â€” Build fork/exec + pipes
âœ” You must implement:
Parent:
pipe(stdin_pipe)
pipe(stdout_pipe)
fork()

Child:
dup2(stdin_pipe[0], STDIN_FILENO)
dup2(stdout_pipe[1], STDOUT_FILENO)
close unused ends
execve(cgi_pass, argv, envp)

Parent:
close child's pipe ends
write body (empty for GET)
read stdout into string
waitpid()

Minimum argv:
argv[0] = interpreter_path (e.g. /usr/bin/python3)
argv[1] = script_path

Minimal env:

Set ONE env var:

REQUEST_METHOD=GET

Evening (2 hours) â€” First real test

Create a file:

cgi-bin/test.py:

#!/usr/bin/python3
print("Content-Type: text/plain\n")
print("Hello CGI")


Run:

GET /cgi-bin/test.py


If your server prints:

Content-Type: text/plain

Hello CGI


ğŸ‰ CGI engine works. Day 1 complete.

ğŸŸ© DAY 2 â€” POST body + Environment Variables + Header Parsing

Goal: CGI can receive POST body and return valid HTTP headers.

Morning (2 hours) â€” Environment Variables

You must add:

REQUEST_METHOD=POST/GET
CONTENT_LENGTH=<body size>
CONTENT_TYPE=<from request header>
PATH_INFO=<file being run>
SCRIPT_FILENAME=<full script path>
QUERY_STRING=<URL ?a=b>
SERVER_PROTOCOL=HTTP/1.1
SERVER_NAME=<server_name>


Only these are required for 42 testing.

Afternoon (3 hours) â€” POST â†’ CGI stdin

For POST:

read request body (already done in Part B)

write to stdin_pipe[1]

Make sure:

close write end after writing (VERY IMPORTANT)

flush buffer (optional)

Test:

cgi-bin/poster.py:

#!/usr/bin/python3
import sys
body = sys.stdin.read()
print("Content-Type: text/plain\n")
print(body)


CURL test:

curl -X POST -d "hello" localhost:8080/cgi-bin/poster.py


Expected output in browser:

hello

Evening (2 hours) â€” Parse CGI Output

CGI output format:

Status: 200 OK
Content-Type: text/html
Set-Cookie: cake=yummy

<html>....</html>

You must split output at the FIRST blank line:
\ r\n\r\n


or

\n\n


Store:

headers in a map

body as string

If CGI didnâ€™t provide Status: â†’ default = 200 OK

ğŸ‰ At this point:

GET works

POST works

You can parse CGI headers

You can return CGI output as HTTP response

Day 2 success.

ğŸŸ¥ DAY 3 â€” Error Handling, Timeouts, File Upload, Stabilizing

Goal: Make CGI stable enough to pass evaluation.

Morning (2 hours) â€” Timeouts

CGI might hang or read forever.

Use alarm(5) or poll() for timeouts.

Simplest (works for 42):

Parent after fork:

alarm(5);
waitpid(child, ...);
alarm(0);


If timeout triggers â†’ kill CGI â†’ return 504.

Midday (2 hours) â€” Error Cases

Handle:

âŒ CGI file not found â†’ 404
âŒ execve fails â†’ 502 Bad Gateway
âŒ CGI returns no output â†’ 500
âŒ CGI missing Content-Type â†’ 500
Afternoon (2 hours) â€” Upload (if needed)

Only required if you support:

upload_dir /path;


If POST request is in an upload location:

write body to file in loc.upload_dir

DO NOT run CGI

This is usually 1â€“2 hours.

Evening (1 hour) â€” Final Integration Tests

Test:

âœ” GET CGI
âœ” POST CGI with body
âœ” Redirect + CGI resolution order
âœ” Error pages
âœ” Timeout
âœ” Bad CGI script

Example bad CGI:

print("zzzzz")


Should return 500.

ğŸŸ¦ TOTAL: 3 DAYS

Day 1 â†’ core engine

Day 2 â†’ POST + headers

Day 3 â†’ stability + errors + upload

This is a realistic, tested schedule.

â­ If you want, I can give you:
âœ” A full CGI runner skeleton
âœ” The exact code structure you need
âœ” Example unit tests
âœ” Python test scripts
âœ” How your CGI module connects to your Router and Response builder

Just say:

ğŸ‘‰ â€œGive me the CGI skeleton.â€
